<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFMS - ë…¸ì„  ìµœì í™”</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        .map-container {
            width: 100%;
            height: 600px;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .step-container {
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 24px;
        }

        .api-settings {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .api-settings h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        .api-input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .destination-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }

        .destination-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border: 1px solid #eee;
            margin-bottom: 10px;
            border-radius: 6px;
            background: #fff;
            gap: 10px;
            transition: all 0.2s;
        }

        .destination-item.confirmed {
            border-color: #2ecc71;
            background-color: #f0fff4;
        }

        .destination-item input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .destination-item .name-input {
            flex: 1;
            font-weight: bold;
        }

        .destination-item .addr-input {
            flex: 2;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn-primary {
            background-color: #4A90E2;
            color: white;
        }

        .btn-primary:hover {
            background-color: #357ABD;
        }

        .btn-success {
            background-color: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        .btn-check {
            background-color: #f39c12;
            color: white;
            padding: 8px 15px;
            font-size: 14px;
        }

        .btn-start {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            margin-top: 10px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, .3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
            vertical-align: middle;
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .log-area {
            width: 100%;
            height: 100px;
            background: #333;
            color: #0f0;
            font-family: monospace;
            padding: 10px;
            margin-top: 20px;
            overflow-y: scroll;
            font-size: 12px;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>
    <div class="dashboard-container">
        <!-- Sidebar -->
        <nav class="sidebar">
            <h3>SFMS Admin</h3>
            <ul>
                <li onclick="location.href='main.html'">ê°€ì…ì •ë³´ ê´€ë¦¬</li>
                <li onclick="location.href='main.html'">ë©”ì‹œì§€ ë³´ë‚´ê¸°</li>
                <li class="active">ë…¸ì„  ìµœì í™”</li>
            </ul>
            <div class="logout-area">
                <a href="#" onclick="logout()">ë¡œê·¸ì•„ì›ƒ</a>
            </div>
        </nav>

        <main class="content">
            <h2>ë…¸ì„  ìµœì í™” (Route Optimization)</h2>

            <!-- API Configuration -->
            <div class="api-settings" style="display:none;">
                <h4>API ì„¤ì • (í•„ìˆ˜)</h4>
                <div class="api-input-group">
                    <div>
                        <label>OpenAI API Key</label>
                        <input type="password" id="openai-key" class="full-width" placeholder="sk-..."
                            value="your openai apk key">
                    </div>
                </div>
                <div class="api-input-group">
                    <div>
                        <label>Naver Maps Client ID (ncloud)</label>
                        <input type="text" id="naver-client-id" placeholder="Client ID ì…ë ¥">
                    </div>
                    <div>
                        <label>Naver Maps Client Secret (ncloud)</label>
                        <input type="password" id="naver-client-secret" placeholder="Client Secret ì…ë ¥ (Geocodingìš©)">
                    </div>
                </div>
                <div class="api-input-group">
                    <div>
                        <label>Naver Search Client ID (Developers)</label>
                        <input type="text" id="naver-search-id" placeholder="Search API ID ì…ë ¥">
                    </div>
                    <div>
                        <label>Naver Search Client Secret (Developers)</label>
                        <input type="password" id="naver-search-secret" placeholder="Search API Secret ì…ë ¥">
                    </div>
                </div>
                <button class="btn btn-primary" onclick="initMapApi()">ì§€ë„ API ìë°”ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œí•˜ê¸°</button>
                <button class="btn btn-warning" onclick="loadApiKeys()"
                    style="margin-left:5px; background-color:#e67e22;">í‚¤ ìë™ ë¡œë“œ</button>
                <div id="api-status" style="margin-top:5px; font-size:12px; color:#666;"></div>
            </div>

            <!-- Step 1: Input -->
            <div class="step-container">
                <h3>1. ëª©ì ì§€ ë¦¬ìŠ¤íŠ¸ ì…ë ¥</h3>
                <p style="color:#666; margin-bottom:10px;">ë°©ë¬¸í•  ì¥ì†Œë“¤ì„ í…ìŠ¤íŠ¸ë¡œ ììœ ë¡­ê²Œ ì…ë ¥í•˜ì„¸ìš”. AIê°€ ì£¼ì†Œë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.</p>
                <textarea id="input-text" rows="5"
                    style="width:100%; padding:10px; border:1px solid #ddd; border-radius:4px;"
                    placeholder="ì˜ˆ: ì„œìš¸íŠ¹ë³„ì‹œ ì†¡íŒŒêµ¬ ì˜¬ë¦¼í”½ë¡œ 300 ë¡¯ë°ì›”ë“œíƒ€ì›Œ, ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 152 ê°•ë‚¨íŒŒì´ë‚¸ìŠ¤ì„¼í„°, ..."></textarea>
                <br><br>
                <button class="btn btn-primary" onclick="extractDestinations()">
                    ëª©ì ì§€ ì¶”ì¶œ <div class="loading" id="loading-extract"></div>
                </button>
            </div>

            <!-- Step 2: Verification -->
            <div class="step-container" id="step-2" style="display:none;">
                <h3>2. ì£¼ì†Œ í™•ì¸ ë° ê²€ì¦</h3>
                <p>ì¥ì†Œëª…(ì˜ˆ: ì†¡íŒŒêµ¬ì²­) ë“± ëŒ€ëµì ì¸ ëª…ì¹­ ìˆì–´ë„ ì •í™•í•œ ì£¼ì†Œë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. </p>
                <p>ë™ëª…ì˜ ì§€ì—­ ë°©ì§€ë¥¼ ìœ„í•´ ì„œìš¸ ì†¡íŒŒêµ¬ì²­ ê³¼ ê°™ì€ ì…ë ¥ì„ ê¶Œì¥í•©ë‹ˆë‹¤</p>
                <p>ì£¼ì†Œê°€ ì˜ëª»ëœ ëª©ì ì§€ê°€ ìˆë‹¤ë©´ ëª©ì ì§€ëª…ì„ ìˆ˜ì • í•œ ë’¤ 'ì£¼ì†Œì¬í™•ì¸' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>

                <div style="margin-bottom:10px;display: none;">
                    <button class="btn btn-warning" id="btn-verify-all" onclick="geocodeAll()"
                        style="background-color:#f39c12; color:white;">
                        ëª¨ë‘ ì£¼ì†Œ ê²€ì¦í•˜ê¸° (ì¼ê´„ ë³€í™˜)
                    </button>
                    <span style="font-size:12px; color:#666; margin-left:10px;">* ë¦¬ìŠ¤íŠ¸ì˜ ëª¨ë“  í•­ëª©ì— ëŒ€í•´ ì£¼ì†Œë¥¼ ê²€ìƒ‰í•˜ì—¬ ì¢Œí‘œë¥¼
                        ê°±ì‹ í•©ë‹ˆë‹¤.</span>
                </div>



                <ul id="dest-list" class="destination-list">
                    <!-- Items inserted here -->
                </ul>

                <button class="btn btn-success btn-start" id="btn-optimize" onclick="optimizeRoute()" disabled>
                    ìµœì  ê²½ë¡œ ìƒì„±í•˜ê¸° (ì§€ë„ í‘œì‹œ)
                </button>
            </div>

            <!-- Step 3: Map -->
            <div class="step-container" id="step-3" style="display:none;">
                <h3>3. ìµœì  ê²½ë¡œ ì§€ë„</h3>
                <div id="map" class="map-container"></div>
                <div id="route-info" style="margin-top:10px; font-weight:bold;"></div>
                <div id="ai-comment"
                    style="margin-top:10px; padding:10px; background:#f0f8ff; border-radius:5px; color:#333; font-size:14px; display:none;">
                </div>
            </div>

            <!-- Debug Log -->
            <div class="log-area" id="debug-log"></div>
        </main>
    </div>

    <script>
        // --- 0. [ë³´ì•ˆ] í† í° ê²€ì¦ ---
        (async function checkAuth() {
            const token = localStorage.getItem('authToken');
            if (!token) {
                alert('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                window.location.href = 'index.html';
                return;
            }
        })();

        function logout() {
            localStorage.removeItem('authToken');
            window.location.href = 'index.html';
        }

        // ì „ì—­ ë³€ìˆ˜
        let map = null;
        let markers = [];
        let polyline = null;
        let destinations = []; // { name, address, lat, lng, confirmed }

        function log(msg) {
            const date = new Date().toLocaleTimeString();
            const logLine = `[${date}] ${msg}\n`;
            $('#debug-log').append(logLine);
            console.log(msg);
        }

        async function loadApiKeys() {
            try {
                // Use Netlify Proxy to bypass Mixed Content (HTTPS -> HTTP blocker)
                const targetUrl = 'http://49.166.98.88:5001/key_request';
                const proxyUrl = `/.netlify/functions/proxy?url=${encodeURIComponent(targetUrl)}`;

                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error('Key server response via proxy was not ok');
                const data = await response.json();

                // Helper to remove last 5 chars (for safety hash)
                const cleanKey = (val) => val ? val.slice(0, -5) : '';

                if (data.A) document.getElementById('openai-key').value = cleanKey(data.A);
                if (data.B) document.getElementById('naver-client-id').value = cleanKey(data.B);
                if (data.C) document.getElementById('naver-client-secret').value = cleanKey(data.C);
                if (data.D) document.getElementById('naver-search-id').value = cleanKey(data.D);
                if (data.E) document.getElementById('naver-search-secret').value = cleanKey(data.E);

                console.log('key loaded');
                document.querySelector('.api-settings').style.display = 'none'; // Hide UI

                // Auto-load Map API if ID exists
                if (document.getElementById('naver-client-id').value) {
                    initMapApi(true); // silent mode
                }

            } catch (e) {
                console.error(e);
                // Silent fail
            }
        }

        // 1. Naver Maps JS ë¡œë“œ
        function initMapApi(silent = false) {
            const clientId = document.getElementById('naver-client-id').value.trim();
            if (!clientId) {
                if (!silent) alert('Naver Client IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (document.getElementById('naver-map-script')) {
                if (!silent) alert('ì´ë¯¸ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
                console.log("Map script already loaded.");
                return;
            }

            const script = document.createElement('script');
            script.id = 'naver-map-script';
            script.src = `https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=${clientId}&submodules=geocoder`;
            script.onload = () => {
                document.getElementById('api-status').innerText = "Naver Maps API (w/ Geocoder) ë¡œë“œ ì„±ê³µ!";
                document.getElementById('api-status').style.color = "green";
                console.log("Map API Loaded");
            };
            script.onerror = () => {
                if (!silent) alert('Naver Maps API ë¡œë“œ ì‹¤íŒ¨. Client IDë¥¼ í™•ì¸í•˜ì„¸ìš”.');
                console.error("Map API Load Error");
            };
            document.head.appendChild(script);
        }

        // 2. OpenAI ì¶”ì¶œ
        async function extractDestinations() {
            const apiKey = document.getElementById('openai-key').value.trim();
            const text = document.getElementById('input-text').value.trim();

            if (!apiKey) { alert('OpenAI API Keyê°€ í•„ìš”í•©ë‹ˆë‹¤.'); return; }
            if (!text) { alert('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'); return; }

            $('#loading-extract').show();

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [
                            {
                                role: "system",
                                content: "ë‹¹ì‹ ì€ ìœ„ì¹˜ ì •ë³´ ì¶”ì¶œ ë„êµ¬ì…ë‹ˆë‹¤. ì‚¬ìš©ìì˜ ì…ë ¥ í…ìŠ¤íŠ¸ì—ì„œ 'ëª©ì ì§€ëª…(name)'ê³¼ 'ì£¼ì†Œ(address)'ë¥¼ ì¶”ì¶œí•˜ì—¬ JSONìœ¼ë¡œ ë°˜í™˜í•˜ì„¸ìš”.\n\n[ê·œì¹™]\n1. ì˜¤ì§ ì‚¬ìš©ìê°€ ì…ë ¥í•œ í…ìŠ¤íŠ¸ ë‚´ì˜ ì •ë³´ë§Œ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ì™¸ë¶€ ì§€ì‹ì„ ì‚¬ìš©í•˜ì—¬ ì£¼ì†Œë¥¼ ì§€ì–´ë‚´ê±°ë‚˜(Hallucination) ë²ˆì—­í•˜ì§€ ë§ˆì‹­ì‹œì˜¤.\n2. ê²°ê³¼ëŠ” ë°˜ë“œì‹œ 'destinations' ë°°ì—´ì„ í¬í•¨í•œ JSON ê°ì²´ì—¬ì•¼ í•©ë‹ˆë‹¤.\n3. ê° í•­ëª©ì€ 'name'ê³¼ 'address' í•„ë“œë¥¼ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤.\n4. í…ìŠ¤íŠ¸ì— ëª…í™•í•œ ì£¼ì†Œê°€ ëª…ì‹œë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´, 'address' í•„ë“œì—ëŠ” 'ëª©ì ì§€ëª…'ì„ ê·¸ëŒ€ë¡œ ë„£ê±°ë‚˜, í…ìŠ¤íŠ¸ ë‚´ì— ìˆëŠ” ì§€ì—­ëª…ê³¼ ê²°í•©í•˜ì—¬(ì˜ˆ: 'ê°•ë™êµ¬ ìƒì¼ì—¬ê³ ') ì ìœ¼ì‹­ì‹œì˜¤.\n5. ì¶œë ¥ì€ ë°˜ë“œì‹œ í•œê¸€ë¡œ í•˜ì‹­ì‹œì˜¤."
                            },
                            {
                                role: "user",
                                content: text
                            }
                        ]
                    })
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                if (!data.choices || data.choices.length === 0) {
                    throw new Error("No choices returned from OpenAI.");
                }

                const content = data.choices[0].message.content;
                log("LLM Response: " + content);

                // JSON íŒŒì‹± (ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ ì œê±° ì²˜ë¦¬)
                let jsonStr = content.replace(/```json/g, '').replace(/```/g, '').trim();
                const result = JSON.parse(jsonStr);

                destinations = result.destinations.map(d => ({
                    name: d.name,
                    address: d.address || d.name, // ì£¼ì†Œ ì—†ìœ¼ë©´ ì´ë¦„ìœ¼ë¡œ ëŒ€ì²´
                    lat: null,
                    lng: null,
                    confirmed: false
                }));

                renderDestinationList();
                $('#step-2').fadeIn();

                // Automation: Start verifying addresses
                await geocodeAll();

            } catch (err) {
                log("Error: " + err.message);
                alert('ëª©ì ì§€ ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n' + err.message);
            } finally {
                $('#loading-extract').hide();
            }
        }

        // 3. ë¦¬ìŠ¤íŠ¸ ë Œë”ë§
        function renderDestinationList() {
            const listEl = document.getElementById('dest-list');
            listEl.innerHTML = '';

            destinations.forEach((dest, index) => {
                const li = document.createElement('li');
                li.className = `destination-item ${dest.confirmed ? 'confirmed' : ''}`;
                li.innerHTML = `
                    <span>${index + 1}.</span>
                    <input type="text" class="name-input" value="${dest.name}" onchange="updateDest(${index}, 'name', this.value)">
                    <input type="text" class="addr-input" value="${dest.address}" onchange="updateDest(${index}, 'address', this.value)">
                    <button class="btn btn-check" onclick="geocodeItem(${index})">ì£¼ì†Œ ì¬í™•ì¸</button>
                    ${dest.confirmed ? 'âœ…' : ''}
                    <button onclick="removeDest(${index})" style="background:none;border:none;cursor:pointer;">âŒ</button>
                    <div style="font-size:11px; color:gray; width:100%; margin-top:5px;">
                        ì¢Œí‘œ: ${dest.lat ? dest.lat.toFixed(6) : '-'}, ${dest.lng ? dest.lng.toFixed(6) : '-'}
                    </div>
                `;
                // Flex wrap fix
                li.style.flexWrap = "wrap";
                listEl.appendChild(li);
            });

            checkAllConfirmed();
        }

        function updateDest(index, field, value) {
            destinations[index][field] = value;
            destinations[index].confirmed = false; // ìˆ˜ì •í•˜ë©´ ë‹¤ì‹œ í™•ì¸ í•„ìš”
            renderDestinationList();
        }

        function removeDest(index) {
            destinations.splice(index, 1);
            renderDestinationList();
        }

        function checkAllConfirmed() {
            const allConfirmed = destinations.length > 1 && destinations.every(d => d.confirmed);
            document.getElementById('btn-optimize').disabled = !allConfirmed;
        }

        // 4. Geocoding Logic (Search API -> Geocode API)
        // 4. Geocoding Logic (Search API -> Geocode API)
        async function searchLocation(query) {
            const searchId = document.getElementById('naver-search-id').value.trim();
            const searchSecret = document.getElementById('naver-search-secret').value.trim();

            if (!searchId || !searchSecret) return null;

            const targetUrl = `https://openapi.naver.com/v1/search/local.json?query=${encodeURIComponent(query)}&display=1&sort=random`;
            const proxyUrl = `/.netlify/functions/proxy?url=${encodeURIComponent(targetUrl)}`;

            try {
                const response = await $.ajax({
                    url: proxyUrl,
                    method: 'GET',
                    dataType: 'json',
                    headers: { 'X-Naver-Client-Id': searchId, 'X-Naver-Client-Secret': searchSecret }
                });

                if (response && response.items && response.items.length > 0) {
                    const item = response.items[0];
                    let rawAddr = item.roadAddress || item.address;
                    let cleanAddr = rawAddr.replace(/<[^>]*>?/gm, '');
                    cleanAddr = cleanAddr.replace(/\s\d+ì¸µ.*$/, '').replace(/\s\w+í˜¸.*$/, '').trim();

                    // Parse mapx, mapy (Integers like 1271234567 => 127.1234567)
                    let lat = null, lng = null;
                    if (item.mapx && item.mapy) {
                        // Naver Search API returns WGS84 scaled by 10,000,000
                        lng = parseInt(item.mapx) / 10000000;
                        lat = parseInt(item.mapy) / 10000000;
                    }

                    return {
                        address: cleanAddr,
                        title: item.title.replace(/<[^>]*>?/gm, ''),
                        lat: lat,
                        lng: lng
                    };
                }
            } catch (e) {
                log(`Search API Failed for ${query}: ${e.message}`);
                if (e.responseText) {
                    try { log("ErrResponse: " + JSON.stringify(JSON.parse(e.responseText))); } catch (xE) { }
                }
            }
            return null;
        }

        // 4. Geocoding (Naver REST API v2)
        async function geocodeItem(index, isBatch = false) {
            const clientId = document.getElementById('naver-client-id').value.trim();
            const clientSecret = document.getElementById('naver-client-secret').value.trim();
            let address = destinations[index].address;
            const name = destinations[index].name;

            // 1. Try to fetch a better address using Naver Search API if we have keys
            const searchedAddress = await searchLocation(name); // Use Name for search
            if (searchedAddress) {
                address = searchedAddress.address;
                destinations[index].address = address; // Update model

                // Use Coordinates from Search API directly if available (Skip Geocode API)
                if (searchedAddress.lat && searchedAddress.lng) {
                    destinations[index].lat = searchedAddress.lat;
                    destinations[index].lng = searchedAddress.lng;
                    destinations[index].confirmed = true;

                    // Update UI input explicitly
                    const listItems = document.querySelectorAll('.destination-item');
                    if (listItems[index]) {
                        listItems[index].querySelector('.addr-input').value = address;
                    }

                    if (!isBatch) {
                        renderDestinationList();
                        log(`Search API Coords Used: ${address} -> ${destinations[index].lat}, ${destinations[index].lng}`);
                    }
                    return true;
                }

                // Update UI input explicitly
                const listItems = document.querySelectorAll('.destination-item');
                if (listItems[index]) {
                    const addrInput = listItems[index].querySelector('.addr-input');
                    if (addrInput) addrInput.value = address;
                }

                if (!isBatch) {
                    renderDestinationList();
                }

                log(`Search Found: ${name} -> ${address}`);
            }

            if (!clientId || !clientSecret) {
                if (!isBatch) alert('Geocodingì„ ìœ„í•´ì„œëŠ” Client IDì™€ Secretì´ ëª¨ë‘ í•„ìš”í•©ë‹ˆë‹¤.');
                return false;
            }

            // ì›ë³¸ Naver API URL
            const targetUrl = `https://maps.apigw.ntruss.com/map-geocode/v2/geocode?query=${encodeURIComponent(address)}`;

            // Netlify Proxyë¥¼ í†µí•œ í˜¸ì¶œ (CORS í•´ê²°)
            const proxyUrl = `/.netlify/functions/proxy?url=${encodeURIComponent(targetUrl)}`;

            try {
                const response = await $.ajax({
                    url: proxyUrl, // Proxy URL ì‚¬ìš©
                    method: 'GET',
                    headers: {
                        'x-ncp-apigw-api-key-id': clientId,
                        'x-ncp-apigw-api-key': clientSecret,
                        'Accept': 'application/json'
                    }
                });

                if (response.status === "OK" && response.addresses && response.addresses.length > 0) {
                    const result = response.addresses[0];
                    destinations[index].lat = parseFloat(result.y);
                    destinations[index].lng = parseFloat(result.x);
                    destinations[index].address = result.roadAddress || result.jibunAddress;
                    destinations[index].confirmed = true;

                    if (!isBatch) {
                        renderDestinationList();
                    }
                    log(`Geocoded: ${destinations[index].name} -> ${destinations[index].address}`);
                    return true;
                } else {
                    if (!isBatch) alert(`'${address}'ì— ëŒ€í•œ ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.`);
                    log(`Geocode Failed for: ${address}`);
                    return false;
                }
            } catch (e) {
                log("Error: " + e.message);
                if (!isBatch) alert('Geocoding Error');
                return false;
            }
        }

        async function geocodeAll() {
            const btn = document.getElementById('btn-verify-all');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = "ì£¼ì†Œ ë³€í™˜ ì¤‘...";

            let successCount = 0;
            for (let i = 0; i < destinations.length; i++) {
                const success = await geocodeItem(i, true);
                if (success) successCount++;
                await new Promise(r => setTimeout(r, 100)); // Rate limiting
            }
            // [ìˆ˜ì • í¬ì¸íŠ¸] ëª¨ë“  ë£¨í”„ê°€ ëë‚œ í›„ ë¦¬ìŠ¤íŠ¸ë¥¼ ë‹¤ì‹œ ê·¸ë ¤ì„œ ì¢Œí‘œ ê°’ì„ í™”ë©´ì— ë°˜ì˜í•©ë‹ˆë‹¤.
            renderDestinationList();
            btn.disabled = false;
            btn.innerText = originalText;
            checkAllConfirmed();
            alert(`ì´ ${destinations.length}ê°œ ì¤‘ ${successCount}ê°œ ì£¼ì†Œ ë³€í™˜ ì™„ë£Œ`);
        }

        // 0. Automation: Load API Keys on Startup
        window.addEventListener('DOMContentLoaded', () => {
            loadApiKeys();
        });


        // 5. ìµœì  ê²½ë¡œ ìµœì í™” (Nearest Neighbor for Simple TSP)
        function optimizeRoute() {
            if (destinations.length < 2) return;

            // 0ë²ˆì§¸ê°€ ì¶œë°œì§€ë¼ê³  ê°€ì •
            // Simple Nearest Neighbor Algorithm
            let unvisited = [...destinations];
            let current = unvisited.shift(); // Start point
            let path = [current];

            while (unvisited.length > 0) {
                let nearestData = null;
                let minDist = Infinity;
                let nearestIdx = -1;

                unvisited.forEach((dest, idx) => {
                    const dist = getDistance(current.lat, current.lng, dest.lat, dest.lng);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestData = dest;
                        nearestIdx = idx;
                    }
                });

                if (nearestIdx !== -1) {
                    current = nearestData;
                    path.push(current);
                    unvisited.splice(nearestIdx, 1);
                } else {
                    break;
                }
            }

            // ê²°ê³¼ ë°˜ì˜
            destinations = path; // ì¬ì •ë ¬
            renderDestinationList(); // ìˆœì„œ ë°”ë€ê²ƒ ë³´ì—¬ì£¼ê¸°

            showMapWithRoute();
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula
            const R = 6371; // km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // 6. ì§€ë„ í‘œì‹œ (Directions 15 API í˜¸ì¶œ)
        async function showMapWithRoute() {
            $('#step-3').show();

            if (!window.naver || !window.naver.maps) {
                alert('ë„¤ì´ë²„ ì§€ë„ APIê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            // ì§€ë„ ì´ˆê¸°í™” (ì²«ë²ˆì§¸ ì§€ì  ì¤‘ì‹¬)
            if (!map) {
                map = new naver.maps.Map('map', {
                    center: new naver.maps.LatLng(destinations[0].lat, destinations[0].lng),
                    zoom: 12
                });
            } else {
                map.setCenter(new naver.maps.LatLng(destinations[0].lat, destinations[0].lng));
            }

            // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
            markers.forEach(m => m.setMap(null));
            markers = [];

            // ë§ˆì»¤ ì¶”ê°€
            destinations.forEach((dest, i) => {
                const marker = new naver.maps.Marker({
                    position: new naver.maps.LatLng(dest.lat, dest.lng),
                    map: map,
                    title: dest.name,
                    icon: {
                        content: `<div style="background:#4A90E2; color:white; padding:5px; border-radius:50%; width:24px; height:24px; text-align:center; font-weight:bold;">${i + 1}</div>`,
                        anchor: new naver.maps.Point(12, 12)
                    }
                });
                markers.push(marker);
            });

            // Driving API í˜¸ì¶œí•˜ì—¬ ê²½ë¡œ ê·¸ë¦¬ê¸°
            await drawDrivingRoute();
        }

        async function drawDrivingRoute() {
            const clientId = document.getElementById('naver-client-id').value.trim();
            const clientSecret = document.getElementById('naver-client-secret').value.trim();

            const start = destinations[0];
            const goal = destinations[destinations.length - 1];

            const startStr = `${start.lng},${start.lat}`;
            const goalStr = `${goal.lng},${goal.lat}`;

            // Waypoints (Middle) - Directions 15 supports max 5 via pipe
            let waypoints = [];
            for (let i = 1; i < destinations.length - 1; i++) {
                waypoints.push(`${destinations[i].lng},${destinations[i].lat}`);
            }
            const waypointsStr = waypoints.join('|');

            // Original Directions 15 URL
            let targetUrl = `https://maps.apigw.ntruss.com/map-direction-15/v1/driving?start=${startStr}&goal=${goalStr}&option=traoptimal`;
            if (waypointsStr) {
                targetUrl += `&waypoints=${waypointsStr}`;
            }

            // Proxy URL
            const proxyUrl = `/.netlify/functions/proxy?url=${encodeURIComponent(targetUrl)}`;

            log("Calling Directions 15 via Proxy: " + targetUrl);

            try {
                await $.ajax({
                    url: proxyUrl,
                    method: 'GET',
                    headers: {
                        'x-ncp-apigw-api-key-id': clientId,
                        'x-ncp-apigw-api-key': clientSecret
                    },
                    success: function (data) {
                        try {
                            // Check if data is string and parse it
                            if (typeof data === 'string') {
                                try { data = JSON.parse(data); } catch (e) { }
                            }

                            if (data.code === 0 && data.route && data.route.traoptimal) {
                                const traoptimal = data.route.traoptimal[0];
                                const path = traoptimal.path; // [[lon, lat], ...]

                                const pathCoords = path.map(p => new naver.maps.LatLng(p[1], p[0]));

                                if (polyline) {
                                    polyline.setMap(null);
                                }

                                polyline = new naver.maps.Polyline({
                                    map: map,
                                    path: pathCoords,
                                    strokeColor: "#e67e22",
                                    strokeWeight: 5
                                });

                                // Summary Info
                                const summary = traoptimal.summary;
                                const distKm = (summary.distance / 1000).toFixed(1);
                                const durMin = (summary.duration / 60000).toFixed(0);
                                $('#route-info').text(`ì´ ê±°ë¦¬: ${distKm}km, ì˜ˆìƒ ì‹œê°„: ${durMin}ë¶„ (Directions 15)`);

                                // Generate AI Comment (updated)
                                const orderedNames = destinations.map(d => d.name);
                                generateRouteComment(orderedNames, distKm, durMin);

                                // Fit bounds to show entire route
                                if (pathCoords.length > 0) {
                                    const bounds = new naver.maps.LatLngBounds();
                                    pathCoords.forEach(p => bounds.extend(p));
                                    map.fitBounds(bounds);
                                }
                            } else {
                                log("Driving API Response Error: " + JSON.stringify(data));
                                alert("ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (API ì‘ë‹µ í™•ì¸ í•„ìš”)");
                            }
                        } catch (e) {
                            log("Parsing Error: " + e.message);
                            alert("ê²½ë¡œ ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
                        }
                    },
                    error: function (err) {
                        log("Driving API Error: " + JSON.stringify(err));
                        alert("Driving 15 API í˜¸ì¶œ ì‹¤íŒ¨. (CORS ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°°í¬ í›„ í™•ì¸í•˜ì„¸ìš”.)");
                        drawDirectLines();
                    }
                });
            } catch (e) {
                console.error(e);
                drawDirectLines();
            }
        }

        async function generateRouteComment(names, distKm, durMin) {
            const apiKey = document.getElementById('openai-key').value.trim();
            if (!apiKey) return;

            const start = names[0];
            const end = names[names.length - 1];
            const waypoints = names.slice(1, names.length - 1).join(', ');

            const prompt = `
            ê²½ë¡œ ì •ë³´:
            - ì „ì²´ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸: ${names.join(' -> ')}
            - ì´ ê±°ë¦¬: ${distKm}km
            - ì˜ˆìƒ ì‹œê°„: ${durMin}ë¶„

            ìœ„ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì•„ë˜ ì–‘ì‹ì„ ì§€ì¼œì„œ ê°€ì‹œì„± ì¢‹ê²Œ ì‘ì„±í•´ì¤˜.

            [ì‘ì„± ì–‘ì‹]
            1. ì•ˆë‚´ ë©˜íŠ¸: "ìš”ì²­í•˜ì‹  ìµœì  ê²½ë¡œë¥¼ ì•ˆë‚´í•´ ë“œë¦½ë‹ˆë‹¤! ğŸš—"
            2. ê²½ë¡œ ë¦¬ìŠ¤íŠ¸:
            - ê° ì¥ì†Œ ì•ì— ìˆ«ìë¥¼ ë¶™ì—¬ì„œ í•œ ì¤„ì— í•˜ë‚˜ì”© ì‘ì„± (1. ì¶œë°œì§€, 2. ê²½ìœ ì§€... n. ëª©ì ì§€)
            3. ìš”ì•½: ì´ ì´ë™ ê±°ë¦¬ì™€ ì†Œìš” ì‹œê°„ì„ í¬í•¨í•œ ë§ˆë¬´ë¦¬ ì¸ì‚¬
            4. íŒ: ë°€ë¦¬ëŠ”ê³³ì´ë‚˜ ì£¼ì˜í• ê³³ì´ ìˆë‹¤ë©´ í•¨ê»˜ ì•Œë ¤ì¤˜

            [ì£¼ì˜ì‚¬í•­]
            - ë°˜ë“œì‹œ ì¤„ë°”ê¿ˆì„ ì‚¬ìš©í•˜ì—¬ ì½ê¸° í¸í•˜ê²Œ í•  ê²ƒ.
            - ê° ì¥ì†Œì˜ ìˆœì„œë¥¼ ì ˆëŒ€ ë°”ê¾¸ì§€ ë§ ê²ƒ.
            - ì •ì¤‘í•˜ê³  ì¹œì ˆí•œ ë§íˆ¬ë¥¼ ì‚¬ìš©í•  ê²ƒ.
            `;

            $('#ai-comment').text("AIê°€ ê²½ë¡œë¥¼ ë¶„ì„ì¤‘ì…ë‹ˆë‹¤...").show();

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [
                            { role: "system", content: "You are a helpful navigation assistant." },
                            { role: "user", content: prompt }
                        ]
                    })
                });

                const data = await response.json();
                if (data.choices && data.choices.length > 0) {
                    const comment = data.choices[0].message.content;
                    $('#ai-comment').html(`ğŸ¤– <b>AI Route Advisor:</b> ${comment}`);
                }
            } catch (e) {
                console.error("AI Comment Error:", e);
                $('#ai-comment').text("");
            }
        }

        // .env íŒŒì¼ ë¡œë“œ í•¨ìˆ˜
        async function loadEnv() {
            try {
                const response = await fetch('./.env');
                if (!response.ok) throw new Error('Cannot load .env file');
                const text = await response.text();

                const lines = text.split('\n');
                lines.forEach(line => {
                    const [key, ...obj] = line.split('=');
                    if (key && obj) {
                        const value = obj.join('=').trim();
                        if (key.trim() === 'OPENAPI_KEY') {
                            document.getElementById('openai-key').value = value;
                        } else if (key.trim() === 'NAVER_CLIENT_ID') {
                            document.getElementById('naver-client-id').value = value;
                        } else if (key.trim() === 'NAVER_CLIENT_SECRET') {
                            document.getElementById('naver-client-secret').value = value;
                        }
                    }
                });
                log(".env loaded successfully");
            } catch (e) {
                log("Failed to load .env (Requires Web Server): " + e.message);
                // Fallback: If fetch fails, we can't do anything in purely client-side static HTML
                // unless we use a build process or the user manually enters keys.
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ .env ë¶ˆëŸ¬ì˜¤ê¸° ì‹œë„ (ì‚¬ìš©ì ìš”ì²­ìœ¼ë¡œ ì œê±° - ìˆ˜ë™ ì…ë ¥ ëª¨ë“œ)
        // window.onload = function () {
        //     loadEnv();
        // };

    </script>
</body>

</html>