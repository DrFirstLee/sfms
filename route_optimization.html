<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFMS - 노선 최적화</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        .map-container {
            width: 100%;
            height: 600px;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .step-container {
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 24px;
        }

        .api-settings {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .api-settings h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        .api-input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .destination-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }

        .destination-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border: 1px solid #eee;
            margin-bottom: 10px;
            border-radius: 6px;
            background: #fff;
            gap: 10px;
            transition: all 0.2s;
        }

        .destination-item.confirmed {
            border-color: #2ecc71;
            background-color: #f0fff4;
        }

        .destination-item input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .destination-item .name-input {
            flex: 1;
            font-weight: bold;
        }

        .destination-item .addr-input {
            flex: 2;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn-primary {
            background-color: #4A90E2;
            color: white;
        }

        .btn-primary:hover {
            background-color: #357ABD;
        }

        .btn-success {
            background-color: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        .btn-check {
            background-color: #f39c12;
            color: white;
            padding: 8px 15px;
            font-size: 14px;
        }

        .btn-start {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            margin-top: 10px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, .3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
            vertical-align: middle;
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .log-area {
            width: 100%;
            height: 100px;
            background: #333;
            color: #0f0;
            font-family: monospace;
            padding: 10px;
            margin-top: 20px;
            overflow-y: scroll;
            font-size: 12px;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>
    <div class="dashboard-container">
        <!-- Sidebar -->
        <nav class="sidebar">
            <h3>SFMS Admin</h3>
            <ul>
                <li onclick="location.href='main.html'">가입정보 관리</li>
                <li onclick="location.href='main.html'">메시지 보내기</li>
                <li class="active">노선 최적화</li>
            </ul>
            <div class="logout-area">
                <a href="index.html">로그아웃</a>
            </div>
        </nav>

        <main class="content">
            <h2>노선 최적화 (Route Optimization)</h2>

            <!-- API Configuration -->
            <div class="api-settings">
                <h4>API 설정 (필수)</h4>
                <div class="api-input-group">
                    <div>
                        <label>OpenAI API Key</label>
                        <input type="password" id="openai-key" class="full-width" placeholder="sk-..."
                            value="your openai apk key">
                    </div>
                    <div>
                        <label>Naver Maps Client ID</label>
                        <input type="text" id="naver-client-id" placeholder="Client ID 입력">
                    </div>
                    <div>
                        <label>Naver Maps Client Secret</label>
                        <input type="password" id="naver-client-secret" placeholder="Client Secret 입력 (Geocoding용)">
                    </div>
                </div>
                <button class="btn btn-primary" onclick="initMapApi()">지도 API 자바스크립트 로드하기</button>
                <div id="api-status" style="margin-top:5px; font-size:12px; color:#666;"></div>
            </div>

            <!-- Step 1: Input -->
            <div class="step-container">
                <h3>1. 목적지 리스트 입력</h3>
                <p style="color:#666; margin-bottom:10px;">방문할 장소들을 텍스트로 자유롭게 입력하세요. AI가 주소를 추출합니다.</p>
                <textarea id="input-text" rows="5"
                    style="width:100%; padding:10px; border:1px solid #ddd; border-radius:4px;"
                    placeholder="예: 서울특별시 송파구 올림픽로 300 롯데월드타워, 강남구 테헤란로 152 강남파이낸스센터, ..."></textarea>
                <br><br>
                <button class="btn btn-primary" onclick="extractDestinations()">
                    목적지 추출 (OpenAI) <div class="loading" id="loading-extract"></div>
                </button>
            </div>

            <!-- Step 2: Verification -->
            <div class="step-container" id="step-2" style="display:none;">
                <h3>2. 주소 확인 및 검증</h3>
                <p>장소명(예: 강동구청)만 있어도 '주소검증'을 통해 정확한 주소로 변환할 수 있습니다.</p>

                <div style="margin-bottom:10px;">
                    <button class="btn btn-warning" id="btn-verify-all" onclick="geocodeAll()"
                        style="background-color:#f39c12; color:white;">
                        모두 주소 검증하기 (일괄 변환)
                    </button>
                    <span style="font-size:12px; color:#666; margin-left:10px;">* 리스트의 모든 항목에 대해 주소를 검색하여 좌표를
                        갱신합니다.</span>
                </div>



                <ul id="dest-list" class="destination-list">
                    <!-- Items inserted here -->
                </ul>

                <button class="btn btn-success btn-start" id="btn-optimize" onclick="optimizeRoute()" disabled>
                    최적 경로 생성하기 (지도 표시)
                </button>
            </div>

            <!-- Step 3: Map -->
            <div class="step-container" id="step-3" style="display:none;">
                <h3>3. 최적 경로 지도</h3>
                <div id="map" class="map-container"></div>
                <div id="route-info" style="margin-top:10px; font-weight:bold;"></div>
            </div>

            <!-- Debug Log -->
            <div class="log-area" id="debug-log"></div>
        </main>
    </div>

    <script>
        // 전역 변수
        let map = null;
        let markers = [];
        let polyline = null;
        let destinations = []; // { name, address, lat, lng, confirmed }

        function log(msg) {
            const date = new Date().toLocaleTimeString();
            const logLine = `[${date}] ${msg}\n`;
            $('#debug-log').append(logLine);
            console.log(msg);
        }

        // 1. Naver Maps JS 로드
        function initMapApi() {
            const clientId = document.getElementById('naver-client-id').value.trim();
            if (!clientId) {
                alert('Naver Client ID를 입력해주세요.');
                return;
            }

            if (document.getElementById('naver-map-script')) {
                alert('이미 로드되었습니다.');
                return;
            }

            const script = document.createElement('script');
            script.id = 'naver-map-script';
            // submodules=geocoder 추가
            script.src = `https://oapi.map.naver.com/openapi/v3/maps.js?ncpClientId=${clientId}&submodules=geocoder`;
            script.onload = () => {
                document.getElementById('api-status').innerText = "Naver Maps API (w/ Geocoder) 로드 성공!";
                document.getElementById('api-status').style.color = "green";
                log("Map API Loaded");
            };
            script.onerror = () => {
                alert('Naver Maps API 로드 실패. Client ID를 확인하세요.');
            };
            document.head.appendChild(script);
        }

        // 2. OpenAI 추출
        async function extractDestinations() {
            const apiKey = document.getElementById('openai-key').value.trim();
            const text = document.getElementById('input-text').value.trim();

            if (!apiKey) { alert('OpenAI API Key가 필요합니다.'); return; }
            if (!text) { alert('텍스트를 입력해주세요.'); return; }

            $('#loading-extract').show();

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-5-nano-2025-08-07",
                        messages: [
                            {
                                role: "system",
                                content: "You are a location extractor. Extract a list of distinct destination names and their addresses (if provided) from the user input. Return ONLY a valid JSON object with a key 'destinations', which is an array of objects having 'name' and 'address' fields. If address is missing, leave it empty."
                            },
                            {
                                role: "user",
                                content: text
                            }
                        ]
                    })
                });

                const data = await response.json();
                const content = data.choices[0].message.content;
                log("LLM Response: " + content);

                // JSON 파싱 (마크다운 코드블록 제거 처리)
                let jsonStr = content.replace(/```json/g, '').replace(/```/g, '').trim();
                const result = JSON.parse(jsonStr);

                destinations = result.destinations.map(d => ({
                    name: d.name,
                    address: d.address || d.name, // 주소 없으면 이름으로 대체
                    lat: null,
                    lng: null,
                    confirmed: false
                }));

                renderDestinationList();
                $('#step-2').fadeIn();

            } catch (err) {
                log("Error: " + err.message);
                alert('목적지 추출 중 오류가 발생했습니다.\n' + err.message);
            } finally {
                $('#loading-extract').hide();
            }
        }

        // 3. 리스트 렌더링
        function renderDestinationList() {
            const listEl = document.getElementById('dest-list');
            listEl.innerHTML = '';

            destinations.forEach((dest, index) => {
                const li = document.createElement('li');
                li.className = `destination-item ${dest.confirmed ? 'confirmed' : ''}`;
                li.innerHTML = `
                    <span>${index + 1}.</span>
                    <input type="text" class="name-input" value="${dest.name}" onchange="updateDest(${index}, 'name', this.value)">
                    <input type="text" class="addr-input" value="${dest.address}" onchange="updateDest(${index}, 'address', this.value)">
                    <button class="btn btn-check" onclick="geocodeItem(${index})">주소확인(Geocode)</button>
                    ${dest.confirmed ? '✅' : ''}
                    <button onclick="removeDest(${index})" style="background:none;border:none;cursor:pointer;">❌</button>
                    <div style="font-size:11px; color:gray; width:100%; margin-top:5px;">
                        좌표: ${dest.lat ? dest.lat.toFixed(6) : '-'}, ${dest.lng ? dest.lng.toFixed(6) : '-'}
                    </div>
                `;
                // Flex wrap fix
                li.style.flexWrap = "wrap";
                listEl.appendChild(li);
            });

            checkAllConfirmed();
        }

        function updateDest(index, field, value) {
            destinations[index][field] = value;
            destinations[index].confirmed = false; // 수정하면 다시 확인 필요
            renderDestinationList();
        }

        function removeDest(index) {
            destinations.splice(index, 1);
            renderDestinationList();
        }

        function checkAllConfirmed() {
            const allConfirmed = destinations.length > 1 && destinations.every(d => d.confirmed);
            document.getElementById('btn-optimize').disabled = !allConfirmed;
        }

        // 4. Geocoding (Naver REST API v2)
        async function geocodeItem(index, isBatch = false) {
            const clientId = document.getElementById('naver-client-id').value.trim();
            const clientSecret = document.getElementById('naver-client-secret').value.trim();
            const address = destinations[index].address;

            if (!clientId || !clientSecret) {
                if (!isBatch) alert('Geocoding을 위해서는 Client ID와 Secret이 모두 필요합니다.');
                return false;
            }

            const url = `https://maps.apigw.ntruss.com/map-geocode/v2/geocode?query=${encodeURIComponent(address)}`;

            try {
                const response = await $.ajax({
                    url: url,
                    method: 'GET',
                    headers: {
                        'x-ncp-apigw-api-key-id': clientId,
                        'x-ncp-apigw-api-key': clientSecret,
                        'Accept': 'application/json'
                    }
                });

                if (response.status === "OK" && response.addresses && response.addresses.length > 0) {
                    const result = response.addresses[0];
                    destinations[index].lat = parseFloat(result.y);
                    destinations[index].lng = parseFloat(result.x);
                    destinations[index].address = result.roadAddress || result.jibunAddress;
                    destinations[index].confirmed = true;

                    if (!isBatch) {
                        renderDestinationList();
                        log(`Geocoded: ${address} -> ${destinations[index].address}`);
                    }
                    return true;
                } else {
                    if (!isBatch) alert(`'${address}'에 대한 검색 결과가 없습니다.`);
                    log(`Geocode Failed for: ${address}`);
                    return false;
                }
            } catch (e) {
                log("Error: " + e.message);
                if (!isBatch) alert('Geocoding Error');
                return false;
            }
        }

        async function geocodeAll() {
            const btn = document.getElementById('btn-verify-all');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = "주소 변환 중...";

            let successCount = 0;
            for (let i = 0; i < destinations.length; i++) {
                const success = await geocodeItem(i, true);
                if (success) successCount++;
                await new Promise(r => setTimeout(r, 100)); // Rate limiting
            }

            renderDestinationList();
            checkAllConfirmed();

            btn.disabled = false;
            btn.innerText = originalText;
            alert(`총 ${destinations.length}건 중 ${successCount}건의 주소를 변환했습니다.`);
        }

        // 5. 최적 경로 최적화 (Nearest Neighbor for Simple TSP)
        function optimizeRoute() {
            if (destinations.length < 2) return;

            // 0번째가 출발지라고 가정
            // Simple Nearest Neighbor Algorithm
            let unvisited = [...destinations];
            let current = unvisited.shift(); // Start point
            let path = [current];

            while (unvisited.length > 0) {
                let nearestData = null;
                let minDist = Infinity;
                let nearestIdx = -1;

                unvisited.forEach((dest, idx) => {
                    const dist = getDistance(current.lat, current.lng, dest.lat, dest.lng);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestData = dest;
                        nearestIdx = idx;
                    }
                });

                if (nearestIdx !== -1) {
                    current = nearestData;
                    path.push(current);
                    unvisited.splice(nearestIdx, 1);
                } else {
                    break;
                }
            }

            // 결과 반영
            destinations = path; // 재정렬
            renderDestinationList(); // 순서 바뀐것 보여주기

            showMapWithRoute();
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula
            const R = 6371; // km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // 6. 지도 표시 (Directions 15 API 호출)
        async function showMapWithRoute() {
            $('#step-3').show();

            if (!window.naver || !window.naver.maps) {
                alert('네이버 지도 API가 로드되지 않았습니다.');
                return;
            }

            // 지도 초기화 (첫번째 지점 중심)
            if (!map) {
                map = new naver.maps.Map('map', {
                    center: new naver.maps.LatLng(destinations[0].lat, destinations[0].lng),
                    zoom: 12
                });
            } else {
                map.setCenter(new naver.maps.LatLng(destinations[0].lat, destinations[0].lng));
            }

            // 기존 마커 제거
            markers.forEach(m => m.setMap(null));
            markers = [];

            // 마커 추가
            destinations.forEach((dest, i) => {
                const marker = new naver.maps.Marker({
                    position: new naver.maps.LatLng(dest.lat, dest.lng),
                    map: map,
                    title: dest.name,
                    icon: {
                        content: `<div style="background:#4A90E2; color:white; padding:5px; border-radius:50%; width:24px; height:24px; text-align:center; font-weight:bold;">${i + 1}</div>`,
                        anchor: new naver.maps.Point(12, 12)
                    }
                });
                markers.push(marker);
            });

            // Driving API 호출하여 경로 그리기
            await drawDrivingRoute();
        }

        async function drawDrivingRoute() {
            const clientId = document.getElementById('naver-client-id').value.trim();
            const clientSecret = document.getElementById('naver-client-secret').value.trim();

            const start = destinations[0];
            const goal = destinations[destinations.length - 1];

            const startStr = `${start.lng},${start.lat}`;
            const goalStr = `${goal.lng},${goal.lat}`;

            // Waypoints (Middle) - Directions 15 supports max 5 via pipe
            // If more than 5, we'll just send first 5 (limitation of demo)
            let waypoints = [];
            for (let i = 1; i < destinations.length - 1; i++) {
                waypoints.push(`${destinations[i].lng},${destinations[i].lat}`);
            }
            // Directions 15 waypoints format: lon,lat|lon,lat|...
            const waypointsStr = waypoints.join('|');

            // Directions 15 URL
            let url = `https://maps.apigw.ntruss.com/map-direction-15/v1/driving?start=${startStr}&goal=${goalStr}&option=traoptimal`;
            if (waypointsStr) {
                url += `&waypoints=${waypointsStr}`;
            }

            log("Calling Directions 15: " + url);

            try {
                await $.ajax({
                    url: url,
                    method: 'GET',
                    headers: {
                        'x-ncp-apigw-api-key-id': clientId,
                        'x-ncp-apigw-api-key': clientSecret
                    },
                    success: function (data) {
                        if (data.code === 0 && data.route && data.route.traoptimal) {
                            const traoptimal = data.route.traoptimal[0];
                            const path = traoptimal.path;
                            const pathCoords = path.map(p => new naver.maps.LatLng(p[1], p[0]));

                            if (polyline) polyline.setMap(null);

                            polyline = new naver.maps.Polyline({
                                map: map,
                                path: pathCoords,
                                strokeColor: "#e67e22",
                                strokeWeight: 5
                            });

                            const summary = traoptimal.summary;
                            $('#route-info').text(`총 거리: ${(summary.distance / 1000).toFixed(1)}km, 예상 시간: ${(summary.duration / 60000).toFixed(0)}분 (Directions 15)`);

                            // Fit bounds
                            const bounds = new naver.maps.LatLngBounds();
                            pathCoords.forEach(p => bounds.extend(p));
                            map.fitBounds(bounds);

                        } else {
                            log("Driving Info: " + data.message);
                            alert("경로 찾기 실패: " + (data.message || "Unknown error"));
                        }
                    },
                    error: function (err) {
                        log("Driving API Error: " + JSON.stringify(err));
                        alert("Driving 15 API 호출 실패 (CORS 확인 필요). 직선으로 표시합니다.");
                        drawDirectLines();
                    }
                });
            } catch (e) {
                console.error(e);
                drawDirectLines();
            }
        }

        // .env 파일 로드 함수
        async function loadEnv() {
            try {
                const response = await fetch('./.env');
                if (!response.ok) throw new Error('Cannot load .env file');
                const text = await response.text();

                const lines = text.split('\n');
                lines.forEach(line => {
                    const [key, ...obj] = line.split('=');
                    if (key && obj) {
                        const value = obj.join('=').trim();
                        if (key.trim() === 'OPENAPI_KEY') {
                            document.getElementById('openai-key').value = value;
                        } else if (key.trim() === 'NAVER_CLIENT_ID') {
                            document.getElementById('naver-client-id').value = value;
                        } else if (key.trim() === 'NAVER_CLIENT_SECRET') {
                            document.getElementById('naver-client-secret').value = value;
                        }
                    }
                });
                log(".env loaded successfully");
            } catch (e) {
                log("Failed to load .env (Requires Web Server): " + e.message);
                // Fallback: If fetch fails, we can't do anything in purely client-side static HTML
                // unless we use a build process or the user manually enters keys.
            }
        }

        // 페이지 로드 시 .env 불러오기 시도
        window.onload = function () {
            loadEnv();
        };

    </script>
</body>

</html>