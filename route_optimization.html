<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFMS - 노선 최적화</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        .map-container {
            width: 100%;
            height: 600px;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .step-container {
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 24px;
        }

        .api-settings {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .api-settings h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        .api-input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .destination-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }

        .destination-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border: 1px solid #eee;
            margin-bottom: 10px;
            border-radius: 6px;
            background: #fff;
            gap: 10px;
            transition: all 0.2s;
        }

        .destination-item.confirmed {
            border-color: #2ecc71;
            background-color: #f0fff4;
        }

        .destination-item input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .destination-item .name-input {
            flex: 1;
            font-weight: bold;
        }

        .destination-item .addr-input {
            flex: 2;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn-primary {
            background-color: #4A90E2;
            color: white;
        }

        .btn-primary:hover {
            background-color: #357ABD;
        }

        .btn-success {
            background-color: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        .btn-check {
            background-color: #f39c12;
            color: white;
            padding: 8px 15px;
            font-size: 14px;
        }

        .btn-start {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            margin-top: 10px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, .3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
            vertical-align: middle;
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .log-area {
            width: 100%;
            height: 100px;
            background: #333;
            color: #0f0;
            font-family: monospace;
            padding: 10px;
            margin-top: 20px;
            overflow-y: scroll;
            font-size: 12px;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>
    <div class="dashboard-container">
        <!-- Sidebar -->
        <nav class="sidebar">
            <h3>SFMS Admin</h3>
            <ul>
                <li onclick="location.href='main.html'">가입정보 관리</li>
                <li onclick="location.href='main.html'">메시지 보내기</li>
                <li class="active">노선 최적화</li>
            </ul>
            <div class="logout-area">
                <a href="index.html">로그아웃</a>
            </div>
        </nav>

        <main class="content">
            <h2>노선 최적화 (Route Optimization)</h2>

            <!-- API Configuration -->
            <div class="api-settings">
                <h4>API 설정 (필수)</h4>
                <div class="api-input-group">
                    <div>
                        <label>OpenAI API Key</label>
                        <input type="password" id="openai-key" class="full-width" placeholder="sk-..."
                            value="your openai apk key">
                    </div>
                </div>
                <div class="api-input-group">
                    <div>
                        <label>Naver Maps Client ID (ncloud)</label>
                        <input type="text" id="naver-client-id" placeholder="Client ID 입력">
                    </div>
                    <div>
                        <label>Naver Maps Client Secret (ncloud)</label>
                        <input type="password" id="naver-client-secret" placeholder="Client Secret 입력 (Geocoding용)">
                    </div>
                </div>
                <div class="api-input-group">
                    <div>
                        <label>Naver Search Client ID (Developers)</label>
                        <input type="text" id="naver-search-id" placeholder="Search API ID 입력">
                    </div>
                    <div>
                        <label>Naver Search Client Secret (Developers)</label>
                        <input type="password" id="naver-search-secret" placeholder="Search API Secret 입력">
                    </div>
                </div>
                <button class="btn btn-primary" onclick="initMapApi()">지도 API 자바스크립트 로드하기</button>
                <button class="btn btn-warning" onclick="loadApiKeys()"
                    style="margin-left:5px; background-color:#e67e22;">키 자동 로드</button>
                <div id="api-status" style="margin-top:5px; font-size:12px; color:#666;"></div>
            </div>

            <!-- Step 1: Input -->
            <div class="step-container">
                <h3>1. 목적지 리스트 입력</h3>
                <p style="color:#666; margin-bottom:10px;">방문할 장소들을 텍스트로 자유롭게 입력하세요. AI가 주소를 추출합니다.</p>
                <textarea id="input-text" rows="5"
                    style="width:100%; padding:10px; border:1px solid #ddd; border-radius:4px;"
                    placeholder="예: 서울특별시 송파구 올림픽로 300 롯데월드타워, 강남구 테헤란로 152 강남파이낸스센터, ..."></textarea>
                <br><br>
                <button class="btn btn-primary" onclick="extractDestinations()">
                    목적지 추출 (OpenAI) <div class="loading" id="loading-extract"></div>
                </button>
            </div>

            <!-- Step 2: Verification -->
            <div class="step-container" id="step-2" style="display:none;">
                <h3>2. 주소 확인 및 검증</h3>
                <p>장소명(예: 강동구청)만 있어도 '주소검증'을 통해 정확한 주소로 변환할 수 있습니다.</p>

                <div style="margin-bottom:10px;">
                    <button class="btn btn-warning" id="btn-verify-all" onclick="geocodeAll()"
                        style="background-color:#f39c12; color:white;">
                        모두 주소 검증하기 (일괄 변환)
                    </button>
                    <span style="font-size:12px; color:#666; margin-left:10px;">* 리스트의 모든 항목에 대해 주소를 검색하여 좌표를
                        갱신합니다.</span>
                </div>



                <ul id="dest-list" class="destination-list">
                    <!-- Items inserted here -->
                </ul>

                <button class="btn btn-success btn-start" id="btn-optimize" onclick="optimizeRoute()" disabled>
                    최적 경로 생성하기 (지도 표시)
                </button>
            </div>

            <!-- Step 3: Map -->
            <div class="step-container" id="step-3" style="display:none;">
                <h3>3. 최적 경로 지도</h3>
                <div id="map" class="map-container"></div>
                <div id="route-info" style="margin-top:10px; font-weight:bold;"></div>
            </div>

            <!-- Debug Log -->
            <div class="log-area" id="debug-log"></div>
        </main>
    </div>

    <script>
        // 전역 변수
        let map = null;
        let markers = [];
        let polyline = null;
        let destinations = []; // { name, address, lat, lng, confirmed }

        function log(msg) {
            const date = new Date().toLocaleTimeString();
            const logLine = `[${date}] ${msg}\n`;
            $('#debug-log').append(logLine);
            console.log(msg);
        }

        async function loadApiKeys() {
            try {
                // Use Netlify Proxy to bypass Mixed Content (HTTPS -> HTTP blocker)
                const targetUrl = 'http://49.166.98.88:5001/key_request';
                const proxyUrl = `/.netlify/functions/proxy?url=${encodeURIComponent(targetUrl)}`;

                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error('Key server response via proxy was not ok');
                const data = await response.json();

                // Helper to remove last 5 chars (for safety hash)
                const cleanKey = (val) => val ? val.slice(0, -5) : '';

                if (data.OPENAPI_KEY) document.getElementById('openai-key').value = cleanKey(data.OPENAPI_KEY);
                if (data.NAVER_CLIENT_ID) document.getElementById('naver-client-id').value = cleanKey(data.NAVER_CLIENT_ID);
                if (data.NAVER_CLIENT_SECRET) document.getElementById('naver-client-secret').value = cleanKey(data.NAVER_CLIENT_SECRET);
                if (data.NAVER_SEARCH_ID) document.getElementById('naver-search-id').value = cleanKey(data.NAVER_SEARCH_ID);
                if (data.NAVER_SEARCH_SECRET) document.getElementById('naver-search-secret').value = cleanKey(data.NAVER_SEARCH_SECRET);

                alert('API 키가 자동으로 로드되었습니다.');
                log('API Keys loaded automatically.');
            } catch (e) {
                console.error(e);
                alert('키 로드 실패: ' + e.message);
            }
        }

        // 1. Naver Maps JS 로드
        function initMapApi() {
            const clientId = document.getElementById('naver-client-id').value.trim();
            if (!clientId) {
                alert('Naver Client ID를 입력해주세요.');
                return;
            }

            if (document.getElementById('naver-map-script')) {
                alert('이미 로드되었습니다.');
                return;
            }

            const script = document.createElement('script');
            script.id = 'naver-map-script';
            // submodules=geocoder 추가
            script.src = `https://oapi.map.naver.com/openapi/v3/maps.js?ncpClientId=${clientId}&submodules=geocoder`;
            script.onload = () => {
                document.getElementById('api-status').innerText = "Naver Maps API (w/ Geocoder) 로드 성공!";
                document.getElementById('api-status').style.color = "green";
                log("Map API Loaded");
            };
            script.onerror = () => {
                alert('Naver Maps API 로드 실패. Client ID를 확인하세요.');
            };
            document.head.appendChild(script);
        }

        // 2. OpenAI 추출
        async function extractDestinations() {
            const apiKey = document.getElementById('openai-key').value.trim();
            const text = document.getElementById('input-text').value.trim();

            if (!apiKey) { alert('OpenAI API Key가 필요합니다.'); return; }
            if (!text) { alert('텍스트를 입력해주세요.'); return; }

            $('#loading-extract').show();

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [
                            {
                                role: "system",
                                content: "당신은 위치 정보 추출 도구입니다. 사용자의 입력 텍스트에서 '목적지명(name)'과 '주소(address)'를 추출하여 JSON으로 반환하세요.\n\n[규칙]\n1. 오직 사용자가 입력한 텍스트 내의 정보만 사용하십시오. 외부 지식을 사용하여 주소를 지어내거나(Hallucination) 번역하지 마십시오.\n2. 결과는 반드시 'destinations' 배열을 포함한 JSON 객체여야 합니다.\n3. 각 항목은 'name'과 'address' 필드를 가져야 합니다.\n4. 텍스트에 명확한 주소가 명시되어 있지 않다면, 'address' 필드에는 '목적지명'을 그대로 넣거나, 텍스트 내에 있는 지역명과 결합하여(예: '강동구 상일여고') 적으십시오.\n5. 출력은 반드시 한글로 하십시오."
                            },
                            {
                                role: "user",
                                content: text
                            }
                        ]
                    })
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                if (!data.choices || data.choices.length === 0) {
                    throw new Error("No choices returned from OpenAI.");
                }

                const content = data.choices[0].message.content;
                log("LLM Response: " + content);

                // JSON 파싱 (마크다운 코드블록 제거 처리)
                let jsonStr = content.replace(/```json/g, '').replace(/```/g, '').trim();
                const result = JSON.parse(jsonStr);

                destinations = result.destinations.map(d => ({
                    name: d.name,
                    address: d.address || d.name, // 주소 없으면 이름으로 대체
                    lat: null,
                    lng: null,
                    confirmed: false
                }));

                renderDestinationList();
                $('#step-2').fadeIn();

                // Automation: Start verifying addresses
                await geocodeAll();

            } catch (err) {
                log("Error: " + err.message);
                alert('목적지 추출 중 오류가 발생했습니다.\n' + err.message);
            } finally {
                $('#loading-extract').hide();
            }
        }

        // 3. 리스트 렌더링
        function renderDestinationList() {
            const listEl = document.getElementById('dest-list');
            listEl.innerHTML = '';

            destinations.forEach((dest, index) => {
                const li = document.createElement('li');
                li.className = `destination-item ${dest.confirmed ? 'confirmed' : ''}`;
                li.innerHTML = `
                    <span>${index + 1}.</span>
                    <input type="text" class="name-input" value="${dest.name}" onchange="updateDest(${index}, 'name', this.value)">
                    <input type="text" class="addr-input" value="${dest.address}" onchange="updateDest(${index}, 'address', this.value)">
                    <button class="btn btn-check" onclick="geocodeItem(${index})">주소확인(Geocode)</button>
                    ${dest.confirmed ? '✅' : ''}
                    <button onclick="removeDest(${index})" style="background:none;border:none;cursor:pointer;">❌</button>
                    <div style="font-size:11px; color:gray; width:100%; margin-top:5px;">
                        좌표: ${dest.lat ? dest.lat.toFixed(6) : '-'}, ${dest.lng ? dest.lng.toFixed(6) : '-'}
                    </div>
                `;
                // Flex wrap fix
                li.style.flexWrap = "wrap";
                listEl.appendChild(li);
            });

            checkAllConfirmed();
        }

        function updateDest(index, field, value) {
            destinations[index][field] = value;
            destinations[index].confirmed = false; // 수정하면 다시 확인 필요
            renderDestinationList();
        }

        function removeDest(index) {
            destinations.splice(index, 1);
            renderDestinationList();
        }

        function checkAllConfirmed() {
            const allConfirmed = destinations.length > 1 && destinations.every(d => d.confirmed);
            document.getElementById('btn-optimize').disabled = !allConfirmed;
        }

        // 4. Geocoding Logic (Search API -> Geocode API)
        // 4. Geocoding Logic (Search API -> Geocode API)
        async function searchLocation(query) {
            const searchId = document.getElementById('naver-search-id').value.trim();
            const searchSecret = document.getElementById('naver-search-secret').value.trim();

            if (!searchId || !searchSecret) return null;

            const targetUrl = `https://openapi.naver.com/v1/search/local.json?query=${encodeURIComponent(query)}&display=1&sort=random`;
            const proxyUrl = `/.netlify/functions/proxy?url=${encodeURIComponent(targetUrl)}`;

            try {
                const response = await $.ajax({
                    url: proxyUrl,
                    method: 'GET',
                    dataType: 'json',
                    headers: { 'X-Naver-Client-Id': searchId, 'X-Naver-Client-Secret': searchSecret }
                });

                if (response && response.items && response.items.length > 0) {
                    const item = response.items[0];
                    let rawAddr = item.roadAddress || item.address;
                    let cleanAddr = rawAddr.replace(/<[^>]*>?/gm, '');
                    cleanAddr = cleanAddr.replace(/\s\d+층.*$/, '').replace(/\s\w+호.*$/, '').trim();

                    // Parse mapx, mapy (Integers like 1271234567 => 127.1234567)
                    let lat = null, lng = null;
                    if (item.mapx && item.mapy) {
                        // Naver Search API returns WGS84 scaled by 10,000,000
                        lng = parseInt(item.mapx) / 10000000;
                        lat = parseInt(item.mapy) / 10000000;
                    }

                    return {
                        address: cleanAddr,
                        title: item.title.replace(/<[^>]*>?/gm, ''),
                        lat: lat,
                        lng: lng
                    };
                }
            } catch (e) {
                log(`Search API Failed for ${query}: ${e.message}`);
                if (e.responseText) {
                    try { log("ErrResponse: " + JSON.stringify(JSON.parse(e.responseText))); } catch (xE) { }
                }
            }
            return null;
        }

        // 4. Geocoding (Naver REST API v2)
        async function geocodeItem(index, isBatch = false) {
            const clientId = document.getElementById('naver-client-id').value.trim();
            const clientSecret = document.getElementById('naver-client-secret').value.trim();
            let address = destinations[index].address;
            const name = destinations[index].name;

            // 1. Try to fetch a better address using Naver Search API if we have keys
            const searchedAddress = await searchLocation(name); // Use Name for search
            if (searchedAddress) {
                address = searchedAddress.address;
                destinations[index].address = address; // Update model

                // Use Coordinates from Search API directly if available (Skip Geocode API)
                if (searchedAddress.lat && searchedAddress.lng) {
                    destinations[index].lat = searchedAddress.lat;
                    destinations[index].lng = searchedAddress.lng;
                    destinations[index].confirmed = true;

                    // Update UI input explicitly
                    const listItems = document.querySelectorAll('.destination-item');
                    if (listItems[index]) {
                        listItems[index].querySelector('.addr-input').value = address;
                    }

                    if (!isBatch) {
                        renderDestinationList();
                        log(`Search API Coords Used: ${address} -> ${destinations[index].lat}, ${destinations[index].lng}`);
                    }
                    return true;
                }

                // Update UI input explicitly
                const listItems = document.querySelectorAll('.destination-item');
                if (listItems[index]) {
                    const addrInput = listItems[index].querySelector('.addr-input');
                    if (addrInput) addrInput.value = address;
                }

                if (!isBatch) {
                    renderDestinationList();
                }

                log(`Search Found: ${name} -> ${address}`);
            }

            if (!clientId || !clientSecret) {
                if (!isBatch) alert('Geocoding을 위해서는 Client ID와 Secret이 모두 필요합니다.');
                return false;
            }

            // 원본 Naver API URL
            const targetUrl = `https://maps.apigw.ntruss.com/map-geocode/v2/geocode?query=${encodeURIComponent(address)}`;

            // Netlify Proxy를 통한 호출 (CORS 해결)
            const proxyUrl = `/.netlify/functions/proxy?url=${encodeURIComponent(targetUrl)}`;

            try {
                const response = await $.ajax({
                    url: proxyUrl, // Proxy URL 사용
                    method: 'GET',
                    headers: {
                        'x-ncp-apigw-api-key-id': clientId,
                        'x-ncp-apigw-api-key': clientSecret,
                        'Accept': 'application/json'
                    }
                });

                if (response.status === "OK" && response.addresses && response.addresses.length > 0) {
                    const result = response.addresses[0];
                    destinations[index].lat = parseFloat(result.y);
                    destinations[index].lng = parseFloat(result.x);
                    destinations[index].address = result.roadAddress || result.jibunAddress;
                    destinations[index].confirmed = true;

                    if (!isBatch) {
                        renderDestinationList();
                        log(`Geocoded: ${address} -> ${destinations[index].address}`);
                        log(`Coordinates saved: ${destinations[index].lat}, ${destinations[index].lng}`);
                    }
                    return true;
                } else {
                    if (!isBatch) alert(`'${address}'에 대한 검색 결과가 없습니다.`);
                    log(`Geocode Failed for: ${address}`);
                    return false;
                }
            } catch (e) {
                log("Error: " + e.message);
                if (!isBatch) alert('Geocoding Error');
                return false;
            }
        }

        async function geocodeAll() {
            const btn = document.getElementById('btn-verify-all');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = "주소 변환 중...";

            let successCount = 0;
            for (let i = 0; i < destinations.length; i++) {
                const success = await geocodeItem(i, true);
                if (success) successCount++;
                await new Promise(r => setTimeout(r, 100)); // Rate limiting
            }

            btn.disabled = false;
            btn.innerText = originalText;
            checkAllConfirmed();
            alert(`총 ${destinations.length}개 중 ${successCount}개 주소 변환 완료`);
        }

        // 0. Automation: Load API Keys on Startup
        window.addEventListener('DOMContentLoaded', () => {
            loadApiKeys();
        });

        renderDestinationList();
        checkAllConfirmed();

        btn.disabled = false;
        btn.innerText = originalText;
        alert(`총 ${destinations.length}건 중 ${successCount}건의 주소를 변환했습니다.`);
        }

        // 5. 최적 경로 최적화 (Nearest Neighbor for Simple TSP)
        function optimizeRoute() {
            if (destinations.length < 2) return;

            // 0번째가 출발지라고 가정
            // Simple Nearest Neighbor Algorithm
            let unvisited = [...destinations];
            let current = unvisited.shift(); // Start point
            let path = [current];

            while (unvisited.length > 0) {
                let nearestData = null;
                let minDist = Infinity;
                let nearestIdx = -1;

                unvisited.forEach((dest, idx) => {
                    const dist = getDistance(current.lat, current.lng, dest.lat, dest.lng);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestData = dest;
                        nearestIdx = idx;
                    }
                });

                if (nearestIdx !== -1) {
                    current = nearestData;
                    path.push(current);
                    unvisited.splice(nearestIdx, 1);
                } else {
                    break;
                }
            }

            // 결과 반영
            destinations = path; // 재정렬
            renderDestinationList(); // 순서 바뀐것 보여주기

            showMapWithRoute();
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula
            const R = 6371; // km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // 6. 지도 표시 (Directions 15 API 호출)
        async function showMapWithRoute() {
            $('#step-3').show();

            if (!window.naver || !window.naver.maps) {
                alert('네이버 지도 API가 로드되지 않았습니다.');
                return;
            }

            // 지도 초기화 (첫번째 지점 중심)
            if (!map) {
                map = new naver.maps.Map('map', {
                    center: new naver.maps.LatLng(destinations[0].lat, destinations[0].lng),
                    zoom: 12
                });
            } else {
                map.setCenter(new naver.maps.LatLng(destinations[0].lat, destinations[0].lng));
            }

            // 기존 마커 제거
            markers.forEach(m => m.setMap(null));
            markers = [];

            // 마커 추가
            destinations.forEach((dest, i) => {
                const marker = new naver.maps.Marker({
                    position: new naver.maps.LatLng(dest.lat, dest.lng),
                    map: map,
                    title: dest.name,
                    icon: {
                        content: `<div style="background:#4A90E2; color:white; padding:5px; border-radius:50%; width:24px; height:24px; text-align:center; font-weight:bold;">${i + 1}</div>`,
                        anchor: new naver.maps.Point(12, 12)
                    }
                });
                markers.push(marker);
            });

            // Driving API 호출하여 경로 그리기
            await drawDrivingRoute();
        }

        async function drawDrivingRoute() {
            const clientId = document.getElementById('naver-client-id').value.trim();
            const clientSecret = document.getElementById('naver-client-secret').value.trim();

            const start = destinations[0];
            const goal = destinations[destinations.length - 1];

            const startStr = `${start.lng},${start.lat}`;
            const goalStr = `${goal.lng},${goal.lat}`;

            // Waypoints (Middle) - Directions 15 supports max 5 via pipe
            let waypoints = [];
            for (let i = 1; i < destinations.length - 1; i++) {
                waypoints.push(`${destinations[i].lng},${destinations[i].lat}`);
            }
            const waypointsStr = waypoints.join('|');

            // Original Directions 15 URL
            let targetUrl = `https://maps.apigw.ntruss.com/map-direction-15/v1/driving?start=${startStr}&goal=${goalStr}&option=traoptimal`;
            if (waypointsStr) {
                targetUrl += `&waypoints=${waypointsStr}`;
            }

            // Proxy URL
            const proxyUrl = `/.netlify/functions/proxy?url=${encodeURIComponent(targetUrl)}`;

            log("Calling Directions 15 via Proxy: " + targetUrl);

            try {
                await $.ajax({
                    url: proxyUrl,
                    method: 'GET',
                    headers: {
                        'x-ncp-apigw-api-key-id': clientId,
                        'x-ncp-apigw-api-key': clientSecret
                    },
                    success: function (data) {
                        if (data.code === 0 && data.route && data.route.traoptimal) {
                            const traoptimal = data.route.traoptimal[0];
                            const path = traoptimal.path;
                            const pathCoords = path.map(p => new naver.maps.LatLng(p[1], p[0]));

                            if (polyline) polyline.setMap(null);

                            polyline = new naver.maps.Polyline({
                                map: map,
                                path: pathCoords,
                                strokeColor: "#e67e22",
                                strokeWeight: 5
                            });

                            const summary = traoptimal.summary;
                            $('#route-info').text(`총 거리: ${(summary.distance / 1000).toFixed(1)}km, 예상 시간: ${(summary.duration / 60000).toFixed(0)}분 (Directions 15)`);

                            // Fit bounds
                            const bounds = new naver.maps.LatLngBounds();
                            pathCoords.forEach(p => bounds.extend(p));
                            map.fitBounds(bounds);

                        } else {
                            log("Driving Info: " + (data.message || JSON.stringify(data)));
                            alert("경로 찾기 실패: " + (data.message || "Unknown error"));
                        }
                    },
                    error: function (err) {
                        log("Driving API Error: " + JSON.stringify(err));
                        alert("Driving 15 API 호출 실패. (CORS 문제일 수 있습니다. 배포 후 확인하세요.)");
                        drawDirectLines();
                    }
                });
            } catch (e) {
                console.error(e);
                drawDirectLines();
            }
        }

        // .env 파일 로드 함수
        async function loadEnv() {
            try {
                const response = await fetch('./.env');
                if (!response.ok) throw new Error('Cannot load .env file');
                const text = await response.text();

                const lines = text.split('\n');
                lines.forEach(line => {
                    const [key, ...obj] = line.split('=');
                    if (key && obj) {
                        const value = obj.join('=').trim();
                        if (key.trim() === 'OPENAPI_KEY') {
                            document.getElementById('openai-key').value = value;
                        } else if (key.trim() === 'NAVER_CLIENT_ID') {
                            document.getElementById('naver-client-id').value = value;
                        } else if (key.trim() === 'NAVER_CLIENT_SECRET') {
                            document.getElementById('naver-client-secret').value = value;
                        }
                    }
                });
                log(".env loaded successfully");
            } catch (e) {
                log("Failed to load .env (Requires Web Server): " + e.message);
                // Fallback: If fetch fails, we can't do anything in purely client-side static HTML
                // unless we use a build process or the user manually enters keys.
            }
        }

        // 페이지 로드 시 .env 불러오기 시도 (사용자 요청으로 제거 - 수동 입력 모드)
        // window.onload = function () {
        //     loadEnv();
        // };

    </script>
</body>

</html>